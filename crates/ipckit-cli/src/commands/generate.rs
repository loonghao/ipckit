//! Code generation command

use crate::{ChannelType, GenerateTarget};
use std::fs;
use std::io::Write;
use std::path::PathBuf;

use super::{print_info, print_success};

/// Generate code templates
pub fn generate(
    target: GenerateTarget,
    channel_type: ChannelType,
    name: &str,
    output: Option<PathBuf>,
    verbose: bool,
) -> Result<(), Box<dyn std::error::Error>> {
    if verbose {
        print_info(&format!(
            "Generating {:?} code for {} channel '{}'",
            target,
            channel_type_name(channel_type),
            name
        ));
    }

    let code = match target {
        GenerateTarget::Client => generate_client(channel_type, name),
        GenerateTarget::Server => generate_server(channel_type, name),
        GenerateTarget::Python => generate_python(channel_type, name),
        GenerateTarget::Handler => generate_handler(name),
    };

    match output {
        Some(path) => {
            let mut file = fs::File::create(&path)?;
            file.write_all(code.as_bytes())?;
            print_success(&format!("Generated code written to: {}", path.display()));
        }
        None => {
            println!("{}", code);
        }
    }

    Ok(())
}

fn channel_type_name(ct: ChannelType) -> &'static str {
    match ct {
        ChannelType::Pipe => "pipe",
        ChannelType::Shm => "shm",
        ChannelType::Socket => "socket",
        ChannelType::File => "file",
        ChannelType::Thread => "thread",
    }
}

fn generate_client(channel_type: ChannelType, name: &str) -> String {
    match channel_type {
        ChannelType::Pipe => format!(
            r#"//! IPC Client for channel: {name}
//!
//! Generated by ipckit CLI

use ipckit::{{IpcChannel, IpcError}};
use serde::{{Deserialize, Serialize}};

#[derive(Debug, Serialize, Deserialize)]
pub struct Request {{
    pub command: String,
    pub params: serde_json::Value,
}}

#[derive(Debug, Serialize, Deserialize)]
pub struct Response {{
    pub success: bool,
    pub data: Option<serde_json::Value>,
    pub error: Option<String>,
}}

pub struct Client {{
    channel: IpcChannel<serde_json::Value>,
}}

impl Client {{
    /// Connect to the IPC server
    pub fn connect() -> Result<Self, IpcError> {{
        let channel = IpcChannel::connect("{name}")?;
        Ok(Self {{ channel }})
    }}

    /// Send a request and receive a response
    pub fn request(&mut self, command: &str, params: serde_json::Value) -> Result<Response, IpcError> {{
        let request = serde_json::json!({{
            "command": command,
            "params": params,
        }});
        self.channel.send(&request)?;
        self.channel.recv()
    }}

    /// Ping the server
    pub fn ping(&mut self) -> Result<String, IpcError> {{
        let response = self.request("ping", serde_json::json!({{}}))?;
        Ok(response.data.unwrap_or_default().to_string())
    }}
}}

fn main() -> Result<(), Box<dyn std::error::Error>> {{
    let mut client = Client::connect()?;

    let response = client.ping()?;
    println!("Server response: {{}}", response);

    Ok(())
}}
"#
        ),
        ChannelType::Socket => format!(
            r#"//! Socket Client for channel: {name}
//!
//! Generated by ipckit CLI

use ipckit::{{SocketClient, IpcError}};
use serde::{{Deserialize, Serialize}};

#[derive(Debug, Serialize, Deserialize)]
pub struct Request {{
    pub command: String,
    pub params: serde_json::Value,
}}

#[derive(Debug, Serialize, Deserialize)]
pub struct Response {{
    pub success: bool,
    pub data: Option<serde_json::Value>,
    pub error: Option<String>,
}}

fn main() -> Result<(), Box<dyn std::error::Error>> {{
    let mut client = SocketClient::connect("{name}")?;

    let request = serde_json::json!({{
        "command": "ping",
        "params": {{}},
    }});

    client.send(&serde_json::to_vec(&request)?)?;
    let response = client.recv()?;

    println!("Response: {{}}", String::from_utf8_lossy(&response));

    Ok(())
}}
"#
        ),
        _ => format!(
            r#"//! Client for {name} ({ct})
//!
//! Generated by ipckit CLI

use ipckit::IpcError;

fn main() -> Result<(), Box<dyn std::error::Error>> {{
    // TODO: Implement client for {ct} channel type
    println!("Client for channel: {name}");
    Ok(())
}}
"#,
            ct = channel_type_name(channel_type)
        ),
    }
}

fn generate_server(channel_type: ChannelType, name: &str) -> String {
    match channel_type {
        ChannelType::Pipe => format!(
            r#"//! IPC Server for channel: {name}
//!
//! Generated by ipckit CLI

use ipckit::{{IpcChannel, IpcError}};
use serde::{{Deserialize, Serialize}};

#[derive(Debug, Serialize, Deserialize)]
pub struct Request {{
    pub command: String,
    pub params: serde_json::Value,
}}

#[derive(Debug, Serialize, Deserialize)]
pub struct Response {{
    pub success: bool,
    pub data: Option<serde_json::Value>,
    pub error: Option<String>,
}}

pub struct Server {{
    channel: IpcChannel<serde_json::Value>,
}}

impl Server {{
    /// Create a new IPC server
    pub fn create() -> Result<Self, IpcError> {{
        let channel = IpcChannel::create("{name}")?;
        Ok(Self {{ channel }})
    }}

    /// Wait for a client to connect
    pub fn wait_for_client(&mut self) -> Result<(), IpcError> {{
        self.channel.wait_for_client()
    }}

    /// Handle incoming requests
    pub fn handle_request(&mut self) -> Result<(), IpcError> {{
        let request: Request = self.channel.recv()?;

        let response = match request.command.as_str() {{
            "ping" => Response {{
                success: true,
                data: Some(serde_json::json!("pong")),
                error: None,
            }},
            "echo" => Response {{
                success: true,
                data: Some(request.params),
                error: None,
            }},
            _ => Response {{
                success: false,
                data: None,
                error: Some(format!("Unknown command: {{}}", request.command)),
            }},
        }};

        self.channel.send(&serde_json::to_value(&response)?)?;
        Ok(())
    }}
}}

fn main() -> Result<(), Box<dyn std::error::Error>> {{
    println!("Starting IPC server on channel: {name}");

    let mut server = Server::create()?;

    loop {{
        println!("Waiting for client...");
        server.wait_for_client()?;

        println!("Client connected, handling requests...");
        if let Err(e) = server.handle_request() {{
            eprintln!("Error handling request: {{}}", e);
        }}
    }}
}}
"#
        ),
        ChannelType::Socket => format!(
            r#"//! Socket Server for channel: {name}
//!
//! Generated by ipckit CLI

use ipckit::{{SocketServer, SocketServerConfig, ConnectionHandler, Connection, Message, IpcError}};
use std::sync::Arc;

struct MyHandler;

impl ConnectionHandler for MyHandler {{
    fn on_connect(&self, conn: &Connection) {{
        println!("Client connected: {{}}", conn.id());
    }}

    fn on_message(&self, conn: &Connection, msg: Message) -> Option<Message> {{
        println!("Received from {{}}: {{}} bytes", conn.id(), msg.data.len());

        // Echo the message back
        Some(msg)
    }}

    fn on_disconnect(&self, conn: &Connection) {{
        println!("Client disconnected: {{}}", conn.id());
    }}
}}

fn main() -> Result<(), Box<dyn std::error::Error>> {{
    println!("Starting socket server on: {name}");

    let config = SocketServerConfig::default();
    let handler = Arc::new(MyHandler);

    let server = SocketServer::new("{name}", config, handler)?;
    server.run()?;

    Ok(())
}}
"#
        ),
        _ => format!(
            r#"//! Server for {name} ({ct})
//!
//! Generated by ipckit CLI

use ipckit::IpcError;

fn main() -> Result<(), Box<dyn std::error::Error>> {{
    // TODO: Implement server for {ct} channel type
    println!("Server for channel: {name}");
    Ok(())
}}
"#,
            ct = channel_type_name(channel_type)
        ),
    }
}

fn generate_python(channel_type: ChannelType, name: &str) -> String {
    match channel_type {
        ChannelType::Pipe => format!(
            r#"""
IPC Client/Server for channel: {name}

Generated by ipckit CLI
"""

import ipckit
import json


class Client:
    """IPC Client for {name}"""

    def __init__(self):
        self.channel = ipckit.IpcChannel.connect("{name}")

    def request(self, command: str, params: dict = None) -> dict:
        """Send a request and receive a response"""
        request = {{
            "command": command,
            "params": params or {{}},
        }}
        self.channel.send(json.dumps(request).encode())
        response = self.channel.recv()
        return json.loads(response.decode())

    def ping(self) -> str:
        """Ping the server"""
        response = self.request("ping")
        return response.get("data", "")


class Server:
    """IPC Server for {name}"""

    def __init__(self):
        self.channel = ipckit.IpcChannel.create("{name}")
        self.handlers = {{
            "ping": self._handle_ping,
            "echo": self._handle_echo,
        }}

    def _handle_ping(self, params: dict) -> dict:
        return {{"success": True, "data": "pong"}}

    def _handle_echo(self, params: dict) -> dict:
        return {{"success": True, "data": params}}

    def run(self):
        """Run the server loop"""
        print(f"Server listening on: {name}")

        while True:
            self.channel.wait_for_client()

            try:
                data = self.channel.recv()
                request = json.loads(data.decode())

                command = request.get("command", "")
                params = request.get("params", {{}})

                handler = self.handlers.get(command)
                if handler:
                    response = handler(params)
                else:
                    response = {{
                        "success": False,
                        "error": f"Unknown command: {{command}}"
                    }}

                self.channel.send(json.dumps(response).encode())
            except Exception as e:
                print(f"Error: {{e}}")


if __name__ == "__main__":
    import sys

    if len(sys.argv) > 1 and sys.argv[1] == "server":
        server = Server()
        server.run()
    else:
        client = Client()
        print(f"Ping response: {{client.ping()}}")
"#
        ),
        _ => format!(
            r#"""
Client/Server for {name} ({ct})

Generated by ipckit CLI
"""

import ipckit


def main():
    # TODO: Implement for {ct} channel type
    print("Channel: {name}")


if __name__ == "__main__":
    main()
"#,
            ct = channel_type_name(channel_type)
        ),
    }
}

fn generate_handler(name: &str) -> String {
    format!(
        r#"//! IPC Handler: {name}
//!
//! Generated by ipckit CLI

use ipckit::{{IpcError, Result}};
use ipckit_macros::{{ipc_handler, command}};
use serde::{{Deserialize, Serialize}};

/// Request message for {name}
#[derive(Debug, Serialize, Deserialize)]
pub struct {name}Request {{
    pub action: String,
    pub data: serde_json::Value,
}}

/// Response message for {name}
#[derive(Debug, Serialize, Deserialize)]
pub struct {name}Response {{
    pub success: bool,
    pub result: Option<serde_json::Value>,
    pub error: Option<String>,
}}

/// Handler for {name} IPC commands
pub struct {name}Handler;

#[ipc_handler(channel = "{name_lower}")]
impl {name}Handler {{
    /// Ping command - returns "pong"
    #[command]
    pub fn ping(&self) -> String {{
        "pong".to_string()
    }}

    /// Echo command - returns the input message
    #[command]
    pub fn echo(&self, message: String) -> String {{
        message
    }}

    /// Add command - adds two numbers
    #[command]
    pub fn add(&self, a: i32, b: i32) -> i32 {{
        a + b
    }}

    /// Process command - processes a request
    #[command]
    pub fn process(&self, request: {name}Request) -> {name}Response {{
        match request.action.as_str() {{
            "greet" => {name}Response {{
                success: true,
                result: Some(serde_json::json!({{
                    "greeting": format!("Hello, {{}}!", request.data.get("name").and_then(|v| v.as_str()).unwrap_or("World"))
                }})),
                error: None,
            }},
            _ => {name}Response {{
                success: false,
                result: None,
                error: Some(format!("Unknown action: {{}}", request.action)),
            }},
        }}
    }}
}}

#[cfg(test)]
mod tests {{
    use super::*;

    #[test]
    fn test_ping() {{
        let handler = {name}Handler;
        assert_eq!(handler.ping(), "pong");
    }}

    #[test]
    fn test_echo() {{
        let handler = {name}Handler;
        assert_eq!(handler.echo("hello".to_string()), "hello");
    }}

    #[test]
    fn test_add() {{
        let handler = {name}Handler;
        assert_eq!(handler.add(2, 3), 5);
    }}
}}
"#,
        name_lower = name.to_lowercase()
    )
}
